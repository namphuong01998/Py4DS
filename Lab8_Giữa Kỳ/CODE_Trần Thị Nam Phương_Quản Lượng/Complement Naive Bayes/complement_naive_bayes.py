# -*- coding: utf-8 -*-
"""Complement Naive Bayes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qf3H8R4_Me4eX21nUMUROIwUiCtHvrGQ
"""

import numpy as np
import pandas as pd
import math
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import ComplementNB
from sklearn.metrics import accuracy_score
rng = np.random.RandomState(42)
rng = np.random.RandomState(1)
X_train = rng.randint(5, size=(6, 100))
y_train = np.array([1, 2, 3, 4, 5, 6])
X_test = X_train[2:3]
print("X_train")
print(X_train)
print("y_train")
print(y_train)

print ("Class and Count")
Class,Count = np.unique(y_train, return_counts = True)
print(Class)
print(Count)

'''
function: MultinomialCalc
Purpose: Calculation log P(value of feature kth|class) by Multinomial
Input:
  - X: train set data
  - y: train set class
  - Class: array of name class
  - k: feature kth
  - value: value to calculation
  - c: index class in Class array
  - alpha: smoothing prior
Output: Result log P(value of feature kth|class) by Multinomial
'''
def ComplementCalc(X,y,feature_c,value,alpha):
  nFeature = 0
  for i in range(len(feature_c)):
    if (feature_c[i] == value):
      nFeature = nFeature + 1
  # caculation result
  res = math.log(nFeature+alpha) - math.log(len(feature_c)+alpha*X.shape[1])
  return res

feature = []
for c in range(Class.shape[0]):
  feature_class = []
  for j in range(X_train.shape[1]):
    feature_col = []
    for i in range(X_train.shape[0]):
      if (y_train[i] != Class[c]):
        feature_col.append(X_train[i][j]);
    feature_class.append(feature_col)
  feature.append(feature_class)

y_pred = []
for i in range(X_test.shape[0]):
  max_value_C = -100000000
  max_position = -1
  for j in range(len(Class)): # c = Class[i]
    #tinh argmax p(X_test[i]|c) = argmax product(p(X_test[i][j]|c)) = argmax sum ln(p(X_test[i][j]|c))
    p_c = math.log(Count[j]/len(y_train))
    sum_ln_proba = 0;
    for k in range(X_train.shape[1]):
      sum_ln_proba = sum_ln_proba + ComplementCalc(X_train,y_train,feature[j][k],X_test[i][k],1);
    sum_weight = p_c - sum_ln_proba
    #print(j,sum_weight, max_value_C)
    if (sum_weight> max_value_C):
      max_value_C = sum_weight
      max_position = j
  y_pred.append(Class[max_position])

print("Self Build Model:")
print(y_pred)

print("ComplementNB sklearn:")
clf = ComplementNB()
clf.fit(X_train, y_train)
y_pred = clf.predict(X_test)
print(y_pred)